# Add measurement data

```@meta
CurrentModule = GeneralizedMetropolisHastings
```

## Creating measurement data

The GMH package requires measurement data to be wrapped in an [`AbstractData`](@ref) object.

Two [`AbstractData`](@ref) subtypes are available. These are likely to cover most
if not all requirements for specifying measurement data. The first is useful
for predefined datasets, the second if data is generated by a function.
This may be the model function itself or a different data generating function.

Create objects of these subtypes with the [`data`](@ref) factory function.

### Predefined datasets

Create a data object wrapping an array with the `data(:array,...)` method. The
wrapped array `values` should have 1 row per data point and 1 column per variable.
Vector `index` contains an index value for each data point.

```@repl
using GeneralizedMetropolisHastings
index = 0:10;
values = 0:0.5:5.0;
d = data(:array,index,values)
```

### Data generating functions

Create a data object wrapping a function with `data(:function!,...)` or `data(:function,...)`.

The first variant requires a function which creates data values in a
preallocated vector `out`, taking it as its first argument.
In the example below, `t` is a time index for each data point,
and the last argument of the `data` function is the `x` argument of
data function `sin!`.

```@repl
using GeneralizedMetropolisHastings
sin!(r::Vector,x::AbstractVector) = (for i=1:length(x) r[i] = sin(x[i]) end ; r)
t = 0.0:0.1:1.0;
out = zeros(t);
d = data(:function!,t,out,sin!,2π*t)
```

The second variant requires a data generating function returning a array with
1 row per data point and 1 column per variable. `t` is a time index for each
data point. In the example below, the final 3 arguments of the `data` function
are the arguments of the `sincos` function.

```@repl
using GeneralizedMetropolisHastings
sincos(x::AbstractVector,a::Real,b::Real) =  cat(2,sin(a*x),cos(b*x));
t = 0.0:0.1:1.0;
d = data(:function,t,sincos,2π*t,2.0,3.0)
```
## Storing data inside the package
Keep predefined data sets in the `data/` subfolder, as explained in
[Set up a folder structure](@ref).

### Small data sets
Small data sets can be stored as an array in a `.jl` file, wrapped
in a function returning an (index,values) tuple.

```julia
function mysmalldataset()
    index = 0:10;
    values = cat(2,0:0.5:5.0,10.0:1.0:20.0); #an 11x2 data array
    return index,values
end
```

The data wrapping function can then be used to create an `:array` data object:

```julia
julia> include("mysmalldataset.jl")
julia> d = data(:array,mysmalldataset()...) #... extracts the returned (index,value) Tuple
```

### Large data sets
For larger data sets, it is recommended to store them in data format files
such as `.jld` or `.mat`.

For more information see the `julia` packages
[JLD](https://github.com/JuliaIO/JLD.jl) and
[MAT](https://github.com/simonster/MAT.jl).

Write data functions that load and extract the data from the data files.
Some examples are provided [here](https://github.com/QuantifyingUncertainty/GMHPhotoReceptor.jl/blob/master/models/datafunctions.jl).

## Using `AbstractData` objects
* Retrieve stored data values with [`datavalues`](@ref)
* Retrieve the index values with [`dataindex`](@ref)
* Get the number of variables and values with [`numvars`](@ref) and [`numvalues`](@ref)
* Generate a new set of values with internal function [`generate!`](@ref)

```@example
using PyPlot
using GeneralizedMetropolisHastings

#define the data object
t = -1.0:0.05:1.0;
d = data(:function,t,sin,2π*t);

#generate a new set of data values
GeneralizedMetropolisHastings.generate!(d);

#retrieve data index and values and plot
plot(dataindex(d),datavalues(d))
title("Data with $(numvars(d)) variable and $(numvalues(d)) values")
xlabel("Time")
ylabel("Values")
xlim(-1.0,1.0)

savefig("dataplot.svg")
```
![](dataplot.svg)

## Extend the `AbstractData` subtype
It is possible to define your own data type by extending [`AbstractData`](@ref).

* Import [`AbstractData`](@ref) and [`data`](@ref) into your package module file
* Define a subtype of [`AbstractData`](@ref)
* Pick a unique symbol (e.g. `:mydata`) for your datatype and define a factory method [`data`](@ref)

```julia
immutable MyDataType <: AbstractData
    field1
    field2
end

function data(::Type{Val{:mydata}},arg1,arg2,arg3,arg4)
    #steps to defined field1 and field2 out of arg1 to arg4
    ...
    MyDataType(field1,field2) #call the constructor of MyDataType
end
```

With that in place, create objects of `MyDataType` as follows:
```julia
d = data(:mydata,arg1,arg2,arg3,arg4)
```

Import and implement methods for all functions listed in
[Data - Public Functions](@ref) and [Data - Internal Functions](@ref)
